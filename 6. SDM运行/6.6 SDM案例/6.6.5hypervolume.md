### hypervolume 

```r
## 学习使用hypervolume 
install.packages("hypervolume")
library(hypervolume)
library(ggplot2)
library(gridExtra)

##  计算多维超体积重叠：
data(iris)
hv1 = hypervolume_gaussian(subset(iris, Species=="virginica")[,1:3])
hv2 = hypervolume_gaussian(subset(iris, Species=="versicolor")[,1:3])
hv_set <- hypervolume_set(hv1, hv2, check.memory=FALSE)
hypervolume_overlap_statistics(hv_set)

data(iris)
e_ball <- expectation_ball(iris[,1:3])


## 生成与最小限度地包含数据的凸壳(多面体)相对应的期望超容积。
data(iris)
e_convex <- expectation_convex(iris[,1:3], check.memory=FALSE)
plot(e_convex)
  

## 获取质心：
data(iris)
hv = hypervolume_gaussian(iris[,1:2])
get_centroid(hv)


## 构建多维超体积：
# 方法如下：
# "box：核密度
# gaussian：高斯
# svm：支持向量机
data(iris)
hv = hypervolume(data=subset(iris, Species=="setosa")[,1:2],method='box')
summary(hv)

## # "box：核密度生成多维超体积；
data(iris)
hv = hypervolume_box(data=subset(iris, Species=="setosa")[,1:2],name='setosa')
summary(hv)
plot3d(hv)
hv@ValueAtRandomPoints


## expectation_maximal
expectation_maximal(iris[,1:3])
 
##  获取三维的坐标：
aa <- get_volume(hv)
plot(aa)


## 计算多维超体积的质心距离：最小欧式距离；
data(iris)
hv1 = hypervolume_gaussian(subset(iris, Species=="virginica")[,1:3])
hv2 = hypervolume_gaussian(subset(iris, Species=="versicolor")[,1:3])

hypervolume_distance(hv1, hv2, type='centroid')
hypervolume_distance(hv1, hv2, type='minimum', num.points.max=500, check.memory=FALSE)

### 计算概率分布：

data(iris)
iris_ss = subset(iris, Species=="setosa")[,1:3]
hv = hypervolume_box(data=iris_ss,name='setosa')
probs <- hypervolume_estimate_probability(hv, points=iris_ss)
# first point should have non-zero density, second, zero

##  计算广义加性模型：
data(iris)
iris[,"Species"] <- iris[,"Species"] == "setosa"
m_glm = glm(Species~.,data=iris)
hv_general_glm = hypervolume_general_model(m_glm,
                                           range.box=padded_range(iris[,1:4]),type='response')
plot(hv_general_glm)


## 投影绘制多维超体积可视化：
# 具体用法是构建模型，然后给一个raster::stack()
hypervolume_project


## 可视化多维超体积：
not run for speed - uncomment to try!
data(iris)
hv = hypervolume_gaussian(iris[,1:3])
plot(hv, show.3d=TRUE)
hypervolume_save_animated_gif()

##  分割超卷积：
data(iris)
hv1 <- hypervolume_gaussian(iris[,1:3],kde.bandwidth=0.1)
hv1_segmented <- hypervolume_segment(hv1, num.points.max=100,
                                     distance.factor=2, check.memory=FALSE)
plot(hv1_segmented)

## 计算多维超体积之间的重叠、合并和差异；结果输出如下：
# HV1 The input hypervolume hv1
# HV2 The input hypervolume hv2
# Intersection The intersection of hv1 and hv2
# Union The union of hv1 and hv2
# Unique_1 The unique component of hv1 relative to hv2
# Unique_2 The unique component of hv2 relative to hv1

hv1 = hypervolume_gaussian(subset(iris, Species=="setosa")[,1:3],
                           name='setosa')
hv2 = hypervolume_gaussian(subset(iris, Species=="virginica")[,1:3],
                           name='virginica')
hv3 = hypervolume_gaussian(subset(iris, Species=="versicolor")[,1:3],
                           name='versicolor')
hv_set12 = hypervolume_set(hv1, hv2, check.memory=FALSE)
hv_set23 = hypervolume_set(hv2, hv3, check.memory=FALSE)
# no overlap found between setosa and virginica
hypervolume_overlap_statistics(hv_set12)
# some overlap found between virginica and versicolor
hypervolume_overlap_statistics(hv_set23)
# examine volumes of each set component
get_volume(hv_set23)

## hypervolume_thin Reduces the number of random points in a hypervolume
## 减少运行代价：
hv1 = hypervolume_gaussian(subset(iris, Species=="setosa")[,1:3])
# downsample to 1000 random points
hv1_thinned = hypervolume_thin(hv1, num.points=1000)
hv1_thinned


### 设置阈值：
data(iris)
hv = hypervolume_gaussian(data=subset(iris, Species=="setosa")[,1:3],name='setosa')
# get hypervolumes at multiple thresholds
hvlist = hypervolume_threshold(hv, plot=TRUE)
head(hvlist$Statistics)
plot(hvlist$HypervolumesThresholded[[c(1,5,10,15,20)]],
     show.random=FALSE, show.data=FALSE,show.centroid=FALSE)
# get hypervolume for a single low quantile value
plot(hypervolume_threshold(hv, plot=FALSE, verbose=FALSE,
                           quantile.requested=0.2,quantile.requested.type="volume")[[1]])



## 设置变量的重要性评估：
data(iris)
hv = hypervolume_gaussian(subset(iris, Species=="versicolor")[,1:2],samples.per.point=10)
varimp = hypervolume_variable_importance(hv,verbose=FALSE)
barplot(varimp)


## 

```

